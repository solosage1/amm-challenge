// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {AMMStrategyBase} from "./AMMStrategyBase.sol";
import {IAMMStrategy, TradeInfo} from "./IAMMStrategy.sol";

contract Strategy is AMMStrategyBase {
    function afterInitialize(uint256 initialX, uint256 initialY) external override
        returns (uint256, uint256) {
        // Store initial ratio (scaled by WAD for precision)
        slots[0] = wdiv(initialY, initialX);
        return (bpsToWad({base_fee_bps}), bpsToWad({base_fee_bps}));
    }

    function afterSwap(TradeInfo calldata trade) external override
        returns (uint256, uint256) {
        uint256 targetRatio = slots[0];
        uint256 currentRatio = wdiv(trade.reserveY, trade.reserveX);

        uint256 baseFee = bpsToWad({base_fee_bps});
        uint256 bidFee = baseFee;
        uint256 askFee = baseFee;

        // If current ratio > target: too much Y (not enough X)
        // Widen ask fee to discourage buying X
        if (currentRatio > targetRatio) {
            uint256 imbalance = wdiv(currentRatio - targetRatio, targetRatio);
            if (imbalance > WAD / {imbalance_threshold_denominator}) {
                askFee = clampFee(baseFee + bpsToWad({adjustment_bps}));
            }
        }
        // If current ratio < target: too much X (not enough Y)
        // Widen bid fee to discourage selling X
        else if (currentRatio < targetRatio) {
            uint256 imbalance = wdiv(targetRatio - currentRatio, targetRatio);
            if (imbalance > WAD / {imbalance_threshold_denominator}) {
                bidFee = clampFee(baseFee + bpsToWad({adjustment_bps}));
            }
        }

        return (bidFee, askFee);
    }

    function getName() external pure override returns (string memory) {
        return "{name}";
    }
}
