// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {AMMStrategyBase} from "./AMMStrategyBase.sol";
import {IAMMStrategy, TradeInfo} from "./IAMMStrategy.sol";

contract Strategy is AMMStrategyBase {
    function afterInitialize(uint256 initialX, uint256 initialY) external override
        returns (uint256, uint256) {
        slots[0] = bpsToWad({base_fee_bps});  // current fee
        slots[1] = wdiv(initialY, initialX);  // target ratio
        slots[2] = 0;  // steps since spike
        return (slots[0], slots[0]);
    }

    function afterSwap(TradeInfo calldata trade) external override
        returns (uint256, uint256) {
        uint256 baseFee = bpsToWad({base_fee_bps});
        uint256 fee = slots[0];
        uint256 targetRatio = slots[1];
        uint256 stepsSinceSpike = slots[2];

        uint256 tradeRatio = wdiv(trade.amountY, trade.reserveY);
        uint256 currentRatio = wdiv(trade.reserveY, trade.reserveX);

        // Signal 1: Size-based adjustment
        bool largeTrade = tradeRatio > WAD / {size_threshold_denominator};

        // Signal 2: Inventory imbalance
        uint256 ratioImbalance = currentRatio > targetRatio
            ? wdiv(currentRatio - targetRatio, targetRatio)
            : wdiv(targetRatio - currentRatio, targetRatio);
        bool imbalanced = ratioImbalance > WAD / {inventory_threshold_denominator};

        // Adjust fee based on combined signals
        if (largeTrade) {
            // Large trade: spike fee immediately
            fee = clampFee(baseFee + bpsToWad({size_spike_bps}));
            stepsSinceSpike = 0;
        } else if (imbalanced) {
            // Imbalanced: moderate increase
            fee = clampFee(baseFee + bpsToWad({inventory_adjustment_bps}));
            stepsSinceSpike++;
        } else {
            // Neither signal: decay towards base
            stepsSinceSpike++;
            if (stepsSinceSpike >= {decay_steps} && fee > baseFee) {
                fee = fee - bpsToWad({decay_rate_bps});
                if (fee < baseFee) fee = baseFee;
            }
        }

        slots[0] = fee;
        slots[2] = stepsSinceSpike;
        return (fee, fee);
    }

    function getName() external pure override returns (string memory) {
        return "{name}";
    }
}
